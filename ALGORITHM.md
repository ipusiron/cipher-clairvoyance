# Cipher Detection and Scoring Algorithms - Technical Reference

## 概要

Cipher Clairvoyanceは、統計分析、パターン認識、エビデンスベーススコアリングを組み合わせた多層アプローチにより古典暗号を識別します。複数の検出アルゴリズムを長さバイアス補正とソフトマックス正規化で統合し、確率的暗号識別を提供します。

## コアアーキテクチャ

### 1. メイン解析パイプライン (analyzer.js)

**エントリーポイント**: `analyzeText(orig, opts={})`
- **入力**: 元の暗号文と解析オプション
- **処理**: 複数の検出アルゴリズムによる順次解析
- **出力**: エビデンススコア付きの確率的結果

**主要処理ステップ**:
1. テキスト前処理: `toAZ(orig)` - 非英字除去、大文字変換
2. 統計分析計算
3. 暗号固有の検出アルゴリズム
4. 長さバイアス補正
5. 確率分布のためのソフトマックス正規化
6. 最大確率による勝者選出

## 統計尺度と数式

### 1. 一致指数 (Index of Coincidence, IC)
**数式**: `IC = Σ(fi(fi-1)) / (N(N-1))`
- **目的**: テキストのランダム性/構造を測定
- **実装**: utils.js の `indexOfCoincidence(s)`
- **期待値**:
  - 英語テキスト: ~0.066
  - ランダムテキスト: ~0.038
  - ヴィジュネル暗号: ~0.04-0.055

### 2. カイ二乗統計量 (χ²)
**数式**: `χ² = Σ((Oi - Ei)² / Ei)`
- **目的**: 観測頻度と期待英語文字頻度の比較
- **実装**: utils.js の `chiSquare(obs, N)`
- **閾値**:
  - 良好な適合: χ² < 20
  - 中程度の適合: χ² < 50
  - 劣悪な適合: χ² > 100

### 3. 英語らしさスコア (Englishness Score)
**アルゴリズム**: バイグラム・トライグラム頻度分析
- **数式**: `0.6 × (bigram_rate / 0.05) + 0.4 × (trigram_rate / 0.02)`
- **実装**: config.js の TOP_BIGRAMS と TOP_TRIGRAMS を使用
- **範囲**: 0.0 - 1.0 (クランプ済み)

## 暗号検出アルゴリズム

### 1. シーザー暗号検出

**アルゴリズム**: analyzers.js の `bestCaesarShiftChi2(s)`
- **手法**: 26通りすべてのシフトの全数探索
- **メトリック**: 各シフトアルファベットのカイ二乗検定
- **選出**: 最小χ²値が最良シフトを示す
- **スコアリング数式**: 
  ```javascript
  caesarScore = clamp01((100 - minChi2) / 100)
  // 英語的IC値(0.06-0.08)のボーナス
  iocBonus = (ioc > 0.06 && ioc < 0.08) ? 1.4 : 1.0
  final_score = caesarScore * iocBonus
  ```

### 2. アフィン暗号検出

**アルゴリズム**: analyzers.js の `bestAffineChi2(s)`
- **手法**: すべての有効な(a,b)パラメーター組み合わせをテスト
- **有効なa値**: [1,3,5,7,9,11,15,17,19,21,23,25] (26と互いに素)
- **変換**: `平文 = ((暗号文 - b) × a⁻¹) mod 26`
- **スコアリング**: シーザー暗号と同じICボーナスシステム

### 3. ヴィジュネル暗号検出

**多段階アルゴリズム**: analyzers.js の `vigenereEvidence(sAZ, useAuto, useCols)`

#### 段階1: 周期検出
**自己相関法**:
- **関数**: `autoCorrelationMatches(s, maxT=40)`
- **数式**: `matches[t] = Σ(s[i] == s[i+t]) / (N-t)`
- **目的**: 異なる間隔での繰り返しパターン検出

**カシスキー法**:
- **関数**: `kasiskiDistances(s, minN=3, maxN=7)`
- **処理**: 繰り返しn-gramを発見し距離を計算
- **重み付け**: 長いn-gram（≥5文字）は2倍の重み
- **GCD分析**: `gcdHistogram(dists, kmax=20)` で共通因子を発見

#### 段階2: 高度な鍵長検出
**アルゴリズム**: `topKeyLengthCandidatesFromPeaks(ac, gcdHist, kmax=20)`

**洗練されたバイアス補正**:
- **小除数ペナルティ**: k ≤ 6 の指数的ペナルティ
  - k ≤ 2: `bias_correction = k⁶`
  - k ≤ 4: `bias_correction = k⁴`
  - k ≤ 6: `bias_correction = k²`
- **長さ優先重み付け**:
  - k ≥ 12: 10× 倍数
  - k ≥ 10: 8× 倍数
  - k ≥ 8: 5× 倍数
  - k < 6: 1% 倍数

**自己相関ボーナスシステム**:
- 強い相関 (>0.055): 3.0× 倍数
- 中程度の相関 (>0.045): 2.0× 倍数
- 弱い相関 (>0.040): 1.5× 倍数

#### 段階3: 列分析
- **IC評価**: ヴィジュネル列の期待IC ~0.04
- **シーザーシフト検出**: 個別列分析
- **スコアリング数式**: `(0.6 × icScore + 0.4 × chiScore) × consistencyBonus`
- **一貫性ボーナス**: 列間のIC分散に基づく

### 4. プレイフェア暗号検出

**アルゴリズム**: analyzers.js の `playfairSuspicion(s)`
- **偶数長チェック**: プレイフェアは常に偶数長出力を生成
- **J文字分析**: 伝統的プレイフェアはI/J置換を使用
- **同一文字分析**: プレイフェアは連続する同一文字を回避
- **X文字頻度**: Xがパディング文字として頻繁に使用

**スコアリング数式**:
```javascript
base_score = 0.35×even + 0.25×jBonus + 0.25×(1-sameRate) + 0.15×xBonus
// 同一文字率ペナルティ
sameRatePenalty = sameRate > 0.06 ? 0.3 : sameRate > 0.04 ? 0.6 : 1.0
final_score = base_score × sameRatePenalty
```

**統計制約** (analyzer.js内):
- **IC範囲ボーナス**: 
  - 最適 (0.09-0.11): 1.4× 倍数
  - 良好 (0.08-0.12): 1.2× 倍数
  - 劣悪 (<0.07 または >0.13): 0.4× 倍数
- **カイ二乗ペナルティ**: χ² > 50000 は 0.6× 倍数
- **長さペナルティ**: N < 200 は 0.6× 倍数

### 5. 転置式暗号検出

**アルゴリズム**: analyzers.js の `englishnessVsTransposition(chisq, eng, sAZ)`
- **コア原理**: 転置は文字頻度を保持
- **主要指標**:
  - 高い英語らしさスコア (>0.85)
  - 英語的IC値 (0.064-0.070)
  - 中程度のχ²値 (>50)

**IC範囲分析**:
- 典型的転置: 0.064-0.070 (1.0× スコア)
- 高IC転置: 0.075-0.085 (0.8× スコア) 
- 広範囲: 0.060-0.090 (0.4× スコア)
- ヴィジュネル範囲 (≤0.055): 0.1× スコア (重いペナルティ)

**スコアリング数式**:
```javascript
score = (0.4×engScore + 0.2×chiScore + 0.4×iocScore) × engBonus
engBonus = eng ≥ 0.95 ? 1.3 : eng ≥ 0.85 ? 1.1 : eng < 0.7 ? 0.2 : 1.0
```

### 6. ADFGX/ADFGVX検出

**アルゴリズム**: analyzers.js の `adfgxDetector(sAZ)`
- **文字セット検証**: 
  - ADFGX: A,D,F,G,X文字のみ許可
  - ADFGVX: A,D,F,G,V,X文字のみ許可
- **長さ要件**: 偶数長必須（座標ペア）
- **スコアリング**: 
  - ADFGVX合致: evidence = 1.0
  - ADFGX合致: evidence = 0.9

## 長さバイアス補正システム

**関数**: analyzer.js の `applyLengthBias(evidences, textLength)`

**閾値カテゴリ**:
- **非常に短い** (≤20文字): 基本暗号への強いバイアス
- **短い** (≤50文字): 基本暗号への中程度バイアス
- **標準** (>50文字): バイアス補正なし

**バイアス調整**:

| 暗号種別 | 非常に短い (≤20) | 短い (≤50) | 標準 (>50) |
|----------|------------------|------------|------------|
| シーザー | 2.0×             | 1.5×       | 1.0×       |
| アフィン | 1.8×             | 1.3×       | 1.0×       |
| ヴィジュネル | 0.3×         | 0.6×       | 1.0×       |
| プレイフェア | 0.4×         | 0.7×       | 1.0×       |
| 転置式   | 1.2×             | 1.1×       | 1.0×       |
| ADFGX    | 0.2×             | 0.5×       | 1.0×       |

## 確率正規化

**ソフトマックス関数**: utils.js の `softmax(scores, tau=0.7)`
- **数式**: `P(i) = exp(score[i]/τ) / Σ(exp(score[j]/τ))`
- **温度パラメーター**: τ = 0.7 (分布の鋭さを制御)
- **目的**: エビデンススコアを確率分布に変換

## エビデンス生成システム

**関数**: evidence.js の `generateEvidence(results)`

### 統計エビデンス分析:
- **IC分析**: 異なる暗号タイプの期待範囲と比較
- **カイ二乗分析**: 英語文字頻度からの偏差評価
- **英語らしさ分析**: 一般的な英語パターンの存在評価

### 暗号固有エビデンス:
各暗号タイプが以下に基づく特定エビデンスを生成:
- **検出信頼度**: 確率閾値ベースの強度評価
- **特徴的特性**: 固有識別子（周期、パラメーター、制約）
- **除外理由**: 他の暗号が除外された理由

### 信頼度レベル:
- **高**: >70% 確率または強い統計合致
- **中**: 40-70% 確率または中程度統計合致
- **低**: <40% 確率または弱い統計指標

## 技術定数と閾値

### 統計閾値:
- **英語IC**: 0.066 ± 0.01 (高信頼度)
- **ヴィジュネルIC**: 0.04-0.055 範囲
- **良好χ²適合**: <30 
- **英語バイグラム率**: 良いテキストで ~5%
- **英語トライグラム率**: 良いテキストで ~2%

### 検出感度:
- **自己相関閾値**: 有意性で >0.035
- **カシスキー最小**: 3-7文字n-gram
- **プレイフェア同一文字率**: <4% 期待
- **転置英語らしさ**: >60% 必須

### バイアス補正パラメーター:
- **短文閾値**: 50文字
- **非常に短文閾値**: 20文字
- **最大入力長**: 10,000文字
- **最小エビデンス下限**: 0.001 (ゼロ確率防止)

## 実装の詳細例

### ヴィジュネル暗号の周期検出プロセス

1. **自己相関計算**:
   ```javascript
   for (let t = 1; t <= maxT; t++) {
     let matches = 0;
     for (let i = 0; i < text.length - t; i++) {
       if (text[i] === text[i + t]) matches++;
     }
     correlation[t] = matches / (text.length - t);
   }
   ```

2. **カシスキー距離分析**:
   ```javascript
   for (let n = minN; n <= maxN; n++) {
     for (let i = 0; i <= text.length - n; i++) {
       const ngram = text.substring(i, i + n);
       const positions = findAllOccurrences(text, ngram);
       if (positions.length > 1) {
         for (let j = 1; j < positions.length; j++) {
           const distance = positions[j] - positions[j-1];
           distances.push(distance);
         }
       }
     }
   }
   ```

3. **GCD分析とピーク検出**:
   ```javascript
   const gcdCounts = {};
   for (const distance of distances) {
     for (let k = 2; k <= Math.min(distance, maxK); k++) {
       if (distance % k === 0) {
         gcdCounts[k] = (gcdCounts[k] || 0) + 1;
       }
     }
   }
   ```

この技術リファレンスは、cipher-clairvoyanceツールが洗練された統計分析とパターン認識技術を通じて「ブラックボックス」暗号識別を実行する方法を理解するための完全なアルゴリズム基盤を提供します。